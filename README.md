# Подготовка к собесу

### Содержание

| №   | Тема                                                                                                                                                                                                       |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1   | [HTML](#HTML)                                                                                                                                                                         |
| 2   | [CSS Sass SCSS](#CSS-Sass-SCSS)                                                                                                         |
| 3   | [JavaScript](#JavaScript)                                                                                                                                                                             |
| 4   | [Паттерны JavaScript](#Паттерны-JavaScript)                     |
| 5   | [TypeScript](#TypeScript)                                                                                                                        |
| 6   | [React](#React)                                                                                                 |
| 7   | [Next JS](#Next-JS)                                                                                                           |
| 8   | [Redux Toolkit And Redux](#Redux-Toolkit-And-Redux)                                                                                                                                     |
| 9   | [Архитектура](#Архитектура)                                                                                                                                         |
| 10  | [Общие](#Общие)                                                                                                                                         |

## Раскидать вопросы

Пусто)

## HTML

1. Что такое HTML.
    
    Это язык гипертекстовой разметки. Нужен для создания скелета/каркаса страницы.
    
2. Какие глобальные атрибуты есть в HTML?
    
    ```jsx
    class, id, style - для стилизации
    data-* - дата атрибуты, например data-testid
    title - позволяет добавить любому элементу подсказку
    ```
    
3. Что такое doctype? И для чего он используется?
    
    ```jsx
    DOCTYPE (Document Type Declaration) - это объявление типа документа, которое
    указывает браузеру или другому парсеру HTML, какая версия HTML или XHTML
    используется в веб-странице.
    
    DOCTYPE играет важную роль при разборе и отображении веб-страницы и выполняет
    следующие функции:
    
    1)Если DOCTYPE не указан или указан некорректно, браузер может переключиться в
    режим совместимости (quirks mode) - это специальный режим, в котором браузер
    интерпретирует веб-страницу с учетом более старых и менее строгих стандартов HTML
    и CSS. Этот режим создан для обеспечения совместимости с устаревшими веб-сайтами,
    которые могли быть разработаны до появления более современных стандартов и
    спецификаций.
    ```
    
4. Опишите базовую структуру HTML-страницы?
    
    ```jsx
    <!DOCTYPE html>
    <html> // Это корневой элемент всей HTML-страницы.
    <head> // метаданные и ссылки на внешние ресурсы, например стили
        <meta charset="UTF-8">
        <title>Заголовок страницы</title>
    </head>
    <body> // Этот элемент содержит основное содержимое страницы
        <!-- Содержимое страницы и элементы отображения и взаимодействия -->
    </body>
    </html>
    ```
    
5. Что такое валидация? И какие типы проверок HTML документа вы знаете?
    
    ```jsx
    Валидация HTML - это процесс проверки HTML-кода веб-страницы на соответствие
    стандартам и правилам, установленным W3C (World Wide Web Consortium)
    
    1) Синтаксическая валидация: Этот тип валидации проверяет, соответствует ли ваш
    HTML-код основным правилам синтаксиса языка. Если в коде есть синтаксические
    ошибки, валидатор сообщит об этом, указав на конкретные строки и местоположения
    ошибок.
    
    2)Структурная валидация: Эта проверка гарантирует, что ваш HTML следует структуре
    документа, установленной стандартами. Это включает в себя правильное вложение
    элементов, наличие обязательных элементов (например, <html>, <head>, <body>) и
    соблюдение семантических правил.
    
    3) Семантическая валидация: Этот аспект валидации оценивает, насколько хорошо вы
    используете элементы HTML с точки зрения их семантики. Правильное использование
    семантики может повысить доступность и SEO-оптимизацию вашей веб-страницы.
    
    4) Проверка на доступность: Этот вид валидации проверяет, насколько ваш HTML-код
    доступен для пользователей с ограниченными возможностями, такими как незрячие или
    люди с ограниченными двигательными способностями.
    ```
    
6. Какой тэг использовать для того, что бы сверстать кнопку?
    
    ```jsx
    А какую именно кнопку сделать?
    // Обычная кнопка
    <button>Button</button>
    
    // Кнопка для формы
    <button type="submit">Button</button>
    <input type="submit" value="Button">
    
    // Через input
    <input type="button" value="Нажми меня">
    
    // Link Button
    <a href="#">Button</a>
    ```
    
7. Что такое инлайновый стиль? Можно ли его переопределить?
    
    ```jsx
    Это стиль который мы задаём напрямую в html через атрибут style. Переопределить его
    можно только с помощью директивы !important
    ```
    
8. Есть ли у HTML элементов свои дефолтные специфичные стили?
    
    ```jsx
    Да, у большинства HTML элементов есть свои дефолтные специфичные стили, которые
    браузеры применяют по умолчанию, если вы не задали стили сами. Эти стили могут
    варьироваться в зависимости от браузера, но есть некоторые общие характеристики.
    
    Примеры: 
    размеры у заголовков h1 h2 h3 и тд
    padding у body
    точки у li
    ссылка становится фиолетовой если на ней были
    
    Как раз для этого используются normalize или reset стили, чтобы была
    кроссбраузерность
    ```
    
9. Что такое семантика? Какие семантичные тэги вы знаете?
    
    ```jsx
    Семантика - это использование правильных тегов, описывающих содержимое контента
    внутри себя.
    
    header - шапка страницы
    footer - подвал страницы
    main - главное содержание страницы, уникальна для каждой страницы
    section - группирует связанный контент внутри страницы в отдельную секцию
    article - используется для выделения отедльный статей, например посты блога
    aside - боковая панель с доп информацией
    nav - навигационное меню
    p - параграф
    h1 - заголовки
    ```
    
10. Типы списков в HTML?
    
    ```jsx
    ul - маркированный список
    ol - нумерованный список
    dl - определительный список
    
    <dl>
      <dt>Термин 1</dt>
      <dd>Определение 1</dd>
      <dt>Термин 2</dt>
      <dd>Определение 2</dd>
    </dl>
    ```
    
11. Для какого тэга используется атрибут alt и зачем он нужен?
    
    ```jsx
    Атрибут alt используется для тега <img>, который используется для вставки
    изображений на веб-страницу. alt - это сокращение от "alternative text"
    (альтернативный текст), и этот атрибут предназначен для предоставления
    текстовой альтернативы изображению.
    
    alt атрибут важен по следующим причинам:
    
    1)Accessibility
    2)SEO
    3)Best UX - если фотка не откроется, пользователь всё равно узнает что там
    ```
    
12. Какая разница между тэгами \<strong\>\<em\> и \<b\>\<i\>?
    
    ```jsx
    // Семантические теги
    strong - жирный текст (логическое выделение)
    em - курсив (логическое выделение)
    
    // Просто для визуализации
    b - жирный текст
    i - курсив
    ```
    
13. Типы \<input\> элементов в HTML?
    
    ```jsx
    <input type="text" name="username">
    
    <input type="password" name="password">
    
    <input type="checkbox" name="subscribe" value="yes">
    
    // У radio должен быть name одинаковый
    <input type="radio" name="gender" value="male"> Мужской
    <input type="radio" name="gender" value="female"> Женский
    
    <input type="submit" value="Отправить">
    
    <input type="reset" value="Сбросить">
    
    <input type="file" name="myfile">
    
    email, url, tel
    
    date, time, datetime-local, month, week
    ```
    
14. Для чего используют data-атрибуты?
    
    ```jsx
    Применяется для хранения различной информации в html, которую в последующем можно
    было использовать в JavaScript
    
    Я пользовался только
    data-testid - когда изучал тестирование
    ```
    
15. Разница между \<script\>, \<script async\> и \<script defer\>?
    
    ```jsx
       script - выполняется сразу при обнаружении на страницы, блокирует дальнейший парсинг html
        async - скрипт исполняется параллельно с чтением html, не ждет разметку
        defer - скрипт загружается фоново, выполняется после полного построения DOM дерева, сохраняет порядок относительно друг друга

    ```
    
    ![Untitled](%D0%9F%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%BA%20%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D1%83%2093e2a86ee4e04252a445c7eb7053cb3a/Untitled.png)
    
16. Что такое мета-тэги?
    
    ```jsx
    Мета-теги (или мета-элементы) являются частью HTML-кода веб-страницы и используются
    для предоставления метаданных о документе.
    
    <meta charset="UTF-8">: Указывает кодировку символов для документа. UTF-8 -
    самая распространенная кодировка, которая поддерживает множество символов и языков.
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">:
    Определяет масштабирование и поведение страницы на мобильных устройствах.
    Этот мета-тег помогает создавать адаптивный дизайн для мобильных устройств.
    
    <meta name="description" content="Описание страницы">: Предоставляет краткое
    описание содержания страницы. Это описание может отображаться в результатах
    поиска, помогая пользователям понять, о чем страница.
    
    <meta name="keywords" content="ключевые слова">: Ранее использовался для указания
    ключевых слов, связанных с содержанием страницы. Однако поисковые системы уже не
    учитывают этот мета-тег для ранжирования страниц.
    ```
    
17. Что описывается в тэге \<head\>?
    
    ```jsx
    Метаданные
    Заголовок страницы
    Подключение внешних файлов
    иконка сайта
    ```
    
18. Для чего используются тэги \<tr\>, \<th\>, \<td\>?
    
    ```jsx
    Они используются при создании таблиц
    <table>
      <tr>
        <th>Имя</th>
        <th>Возраст</th>
      </tr>
      <tr>
        <td>Анна</td>
        <td>25</td>
      </tr>
      <tr>
        <td>Иван</td>
        <td>30</td>
      </tr>
    </table>
    
    tr - table row - строки таблицы
    th - table header cell - ячейка заголовка таблицы
    td - table data cell - обычная ячейка
    ```
    
19. Что такое svg
    
    ```jsx
    Векторная графика
    ```
    
20. Для чего нужен атрибут autocomplete?
    
    ```jsx
    Нужен для управление автозаполнения данных в полях формы.
    on - Значение по умолчанию. Браузер предоставляет предложения для автозаполнения
    off - Отключает автозаполнение
    ```
    
21. Что такое атрибут target? Какие значения он принимает?
    
    ```jsx
    Применяется к <a></a>
    _blank - ресурс должен открыться на новой вкладке
    _self - по умолчанию
    ```
    
22. Как семантически верно сверстать навигационное меню?
    
    ```jsx
    <nav>
      <ul>
        <li><a href="/">Главная</a></li>
        <li><a href="/о-нас">О нас</a></li>
        <li><a href="/контакты">Контакты</a></li>
        <!-- Добавьте другие пункты меню, если необходимо -->
      </ul>
    </nav>
    ```
    
23. Что такое \<iframe\>?
    
    ```jsx
    <iframe> (Inline Frame) - это элемент HTML, который используется для вставки
    другой веб-страницы или внешнего контента в текущую веб-страницу
    
    Я использовал вставку гугл карт с помощью Iframe
    ```
    
24. Для чего используются тэги \<sub\> и \<sup\>?
    
    ```jsx
    sub - нижний индекс, как в H20
    sup - верхний индекс, как в м2
    ```
    
25. Как можно скрыть элемент разметки не используя CSS и JS?
    
    ```jsx
    Добавить атрибут hidden
    ```
    
26. Как можно изменить форму картинки или HTML элемента?
    
    ```jsx
    добавить отрибуты width и height тегу img
    ```
    
28. Чем отличается \<article\> от \<section\>?
    
    ```jsx
    <article> предназначен для обозначения независимого и самодостаточного
    содержимого на веб-странице. Это может быть, например, новостная статья,
    блоговая запись, комментарий, форумное сообщение
    
    <section> используется для группировки и организации смысловых блоков
    контента на веб-странице. Это помогает структурировать страницу и делать
    ее более понятной для поисковых систем и читателей.
    ```
    
29. Разница между кнопкой и ссылкой в HTML?
    
    ```jsx
    Кратко говоря, кнопка (<button>) используется для выполнения действий на текущей
    странице, а ссылка (<a>) используется для перехода на другие страницы или ресурсы.
    Каждый из них имеет свое место и назначение в веб-разработке, и их выбор зависит
    от конкретной задачи.
    ```
    
30. Почему стоит использовать семантические теги в верстке?
    
    ```jsx
    Улучшение доступности: Семантические теги предоставляют ясную структуру и смысл
    вашей веб-страницы. Это позволяет пользователям с ограниченными возможностями,
    таким как пользователи скринридеров, лучше понимать и навигировать по странице.
    Семантическая разметка делает ваш сайт более доступным для всех пользователей.
    
    Улучшение SEO: Поисковые системы, такие как Google, используют семантическую
    разметку для понимания структуры и содержания веб-страницы. Используя
    семантические теги, вы помогаете поисковым системам более точно индексировать
    ваш контент и улучшать позиции в результатах поиска.
    
    Легкость в обслуживании и разработке: Семантические теги делают код более
    читаемым и понятным для разработчиков. Они обеспечивают ясную структуру
    документа и позволяют быстрее находить и вносить изменения в код.
    ```

31. Распишите, чем отличаются следующие параметры тега link
    ```jsx
        <link rel="preload" />
        <link rel="prefetch" />
        <link rel="dns-prefetch" />
        <link rel="preconnect" />
        <link rel="prerender" />
    ```

    ```html
        preload говорит браузеру: "Заранее загрузите этот ресурс, потому что я его скоро использую." Например, если на странице будет какой-то шрифт или картинка, которая понадобиться сразу после загрузки страницы, то мы можем использовать preload:
        <link rel="preload" href="image.jpg" as="image" />
        Представь, что ты ждёшь автобус. Если ты заранее стоишь на нужной остановке, то тебе не нужно будет долго ждать, когда автобус приедет.

        prefetch говорит браузеру: "Загрузи этот ресурс, но не сейчас, а немного позже. Он будет нужен на следующей странице, когда пользователь туда перейдёт." Например, если ты знаешь, что на следующей странице будет видео или картинка, ты можешь сказать браузеру            заранее загрузить их:
        <link rel="prefetch" href="next-page-video.mp4" />
        Это как если ты слышишь, что через несколько минут нужно будет идти на другую остановку, и ты заранее начинаешь двигаться в ту сторону, чтобы не терять время.

        dns-prefetch помогает браузеру быстрее подключаться к серверу. Когда ты заходишь на сайт, браузер должен сначала узнать, где находится сервер, а затем подключиться к нему. Если ты заранее скажешь браузеру, к какому серверу подключаться, он не будет терять              время на поиск адреса:
        <link rel="dns-prefetch" href="https://example.com" />
        Это как если ты заранее узнаешь, где будет твоя следующая остановка, чтобы не терять время на поиск маршрута.

        preconnect говорит браузеру: "Начни соединяться с сервером заранее, потому что скоро я буду загружать ресурсы с этого сервера." Например, если ты заранее знаешь, что тебе нужно будет подключиться к серверу для загрузки шрифтов или других данных, ты можешь              использовать preconnect:
        <link rel="preconnect" href="https://example.com" />
        Это как если ты заранее будешь готовиться к встрече с другом, начинаешь разглядывать его в толпе, чтобы встретиться быстрее.

        prerender говорит браузеру: "Загрузи целую страницу заранее. Мы будем на неё переходить, и ты можешь загрузить её ресурсы прямо сейчас." Это помогает, когда ты точно знаешь, что пользователь перейдёт на эту страницу. Например:
        <link rel="prerender" href="next-page.html" />
        Это как если ты заранее приготовишь всё для завтра, чтобы не тратить время на подготовку в последний момент.
    ```

32. Расскажи про Рендеринг WEB-страницы
    ```jsx
    Какие стили надо поменять, чтобы вызвать Relayout?
    Какие стили надо поменять чтобы вызывать Repaint?
    Какие стили надо поменять чтобы вызвать Recompositing?
    Какие этапы отрисовки произойдут, если вызвать Relayout?
    Какие этапы отрисовки произойдут, если вызвать Repaint?
    ```


    ```jsx
    1. Запрос html
    2. Когда браузер получит html, браузер начинает его парсить и строить DOM дерево
    3. CSSOM строится по мере парсинга CSS, но она не может быть использована для построения Render Tree, потому что может оказаться так, что следующий набор правил, может сделать какой-нибудь из узлов дерева невидимым на экране, это может вызвать перерасчёт стилей
    4. Когда DOM & CSSOM готовы, браузер создаёт Render tree, это дерево которое даёт представление о том, что в итоге будет отображаться на странице. В Render tree попадают только видимые элементы.
    5. Layout - этот этап определяет, где и как на странице, будут спозиционированы элементы и каковы будут связи между ними. Глобальный Layout — это процесс просчёта всего дерева полностью, то есть каждого элемента. Инкрементальный — просчитывает только часть.
    6. Paint - отрисовка пикселей на экране. Это самый дорогой процесс
    7. Composite - разделение содержимого страницы на «слои», которые браузер будет перерисовывать. Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.
    
    1)Relayout (или Reflow) — это процесс пересчета геометрии (положения и размеров) элементов в документе. Изменение любого свойства, влияющего на геометрию элемента или его соседей, вызовет рефлоу.
    Размеры: width, height, padding, border, margin
    Позиционирование: top, left, right, bottom, position (при изменении значений)
    Геометрия содержимого: font-size, line-height, text-align
    Структура DOM: добавление/удаление видимых элементов, изменение текста (меняет размеры)
    Активация псевдоклассов: :hover, :focus (если меняют геометрию)
    Чтение "метрик" в JavaScript: offsetWidth, offsetHeight, getComputedStyle().
    2) Repaint — это процесс перерисовки пикселей на экране, когда внешний вид элемента изменился, но его геометрия (и геометрия других элементов) осталась прежней.
    Цвета: color, background-color, border-color
    Видимость/обводка: outline, box-shadow, visibility: hidden
    Фоновые изображения: background-image (загрузка нового), background-size, background-position
    Декоративные свойства: text-decoration
    3) Compositing (композитинг) — это финальный этап, когда браузер рисует предварительно подготовленные слои (layers) на GPU. Изменение свойств, которые обрабатываются композитором, позволяет избежать Relayout и Repaint, что наиболее эффективно для анимаций.
    Трансформации: transform: translate(), scale(), rotate() (аппаратное ускорение)
    Непрозрачность: opacity
    Фильтры: filter (blur, grayscale и т.д.)
    Свойство-подсказка: will-change: transform, opacity (предварительно помещает элемент в отдельный слой).
    
    При вызове Relayout произойдут следующие этапы: Style Recalculation, Repaint, Recompositing
    При вызове Repaint произойдут следующие этапы: Style Recalculation, Recompositing
    ```


## CSS Sass SCSS

1. Что такое CSS? И для чего он используется?
    
    ```jsx
    CSS - каскадная таблица стилей. Нужен для добавления различных стилей на HTML
    страницу.
    ```
    
2. Что такое CSS-правило?
    
    ```jsx
    CSS-правило формируется из двух основных составляющих
    
    selector - это правило по которому на html странице будет происходить выборка
    элементов для стилизации
    
    declaration - блок объявления, это структура содержащая фигурные скобки внутри
    которых описываются property(свойства) и value(значения), после чего стили будут
    применены к найденым элементам
    ```
    
3. Варианты добавление CSS стилей на страницу?
    
    ```jsx
    Существуют 4 основных способа.
    
    1) Инлайн стили
    2) использование тега style внутри head
    3) использование внешнего файла и подключения через link
    4) импорт css @import
    ```
    
4. Свойство position. Какие значения принимает и как работают
    
    ```jsx
    static - по умолчанию, статическое позиционирование
    
    relative - сдвигает элемент относительно его обычного расположения
    
    absolute - исчезает с того места где он был и позиционируется заново, остальные
    элементы позиционируются так, будто этого элемента и не было. Позиционируется от
    relative родителя
    
    fixed - крепится к экрану и находится там, даже с учётом прокрутки
    
    sticky - похож на fixed, только крепится в рамках какого-то блок
    ```
    
5. Блочная модель CSS
    
    ```jsx
    это алгоритм расчёта размеров каждого отдельного элемента на странице, которым
    браузеры пользуются при отрисовке
    В неё входит:
    content width
    content height
    padding
    border
    margin
    ```
    
6. Что такое селектор? И какие селекторы существуют?
    
    ```jsx
    Это часть CSS-правила которое сообщает браузеру какому элементу или элементам
    страницы будет применён стиль.
    
    // Простые селекторы
    .class
    #id
    p
    *
    a[href="test"] - по атрибуту
    
    // Составные селекторы
    h1, h2, span {}
    div p {}
    li > a {}
    a:hover {}
    li:first-child {}
    ```
    
7. Какие комбинаторы существуют
    
    ```jsx
    " " - пробел. Потомки любой вложенности
    > - Только дочерние компоненты.
    ~ - комбинатор соседних компонентов
    + - комбинатор непосредственно соседних элементов
    ```
    
8. Что такое специфичность селектора? Как считать вес селектора?
    
    ```jsx
    Это способ, с помощью которого браузеры определяют какие значения CSS свойств
    будут применены к элементу.
    !important > inline-style > #id > .class > tag
    ```
    
    ![Untitled](%D0%9F%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%BA%20%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D1%83%2093e2a86ee4e04252a445c7eb7053cb3a/Untitled%201.png)
    
9. Разница между Reset.css и Normalize.css?
    
    ```jsx
    Большинство html элементов обладают дефолтными стилями. Каждый браузер применяет
    различные стили
    
    reset - Это css файл который сбрасывает все дефолтные стили
    normalize - это css файл который нормализирует стили. Делает их одинаковыми
    ```
    
10. Различия margin и padding
    
    ```jsx
    margin - внешний отступ
    padding - внутренний отступ
    ```
    
11. Разница между display: none и visibility: hidden?
    
    ```jsx
    display: none - Элемент не показывает на экране вообще и удаляется из потока
    visibility: hidden - элемент скрывается и не вырывается из основного потока и
    занимает место
    ```
    
12. Свойство display. Какие значения принимает и как работает.
    
    ```jsx
    none - элемент не показывается на экране вообще
    block - блочный элемент которые располагают один над другим вертикально, блок
    стремится расшириться на всю ширину
    inline - располагаются на одной строке, ширина и высота определяется по
    содержимому и менять ширину и высоту нельзя
    inline-block - как inline Но можно менять ширину и высоту
    flex
    grid
    ```
    
13. Разница между классом и идентификатором в CSS?
    
    ```jsx
    id - уникален на всю страницу
    class - можно задавать много раз
    ```
    
14. Что такое CSS спрайт? И для чего он используется?
    
    ```jsx
    Это картинка которая объединяет несколько изображений в одно большое.
    Обычно такое используется для набора иконок.
    
    Это сокращает количество обращений к серверу,
    ```
    

15. Что такое вендорные префиксы? И для чего они используются?

    ```jsx
    Это приставка к CSS свойству которое обеспечивает поддержку данного свойства
    браузерами в которых оно не внедрено на постоянной основе.
    -webkit - Chrome, Safari
    -moz - Firefox
    -ms - Internet Explorer, Edge
    -o - Opera
    ```

16. Что такое псевдоэлементы? И для чего они используются?
    
    ```jsx
    Это ключевое слово которое добавляется на селектор и позволяет стилизировать 
    определённую часть выбранного элемента.
    h2::first-letter - используется для изменения первой буквы в тексте
    h2::first-line - используется для изменения первой строки блочного текста
    h2::after - применяется для вставки нужного контента после выбранного элемента
    h2::before- применяется для вставки нужного контента до выбранного элемента
    ```
    
17. Что такое схлопывание границ (margin collapsing)?
    
    ```jsx
    Это механизм взаимодействия отступов по вертикали. Это наблюдается когда у блочных
    элементов расположенных друг под другом, отступы не суммируются, а объединяются
    между собой, в результате итоговое расстояние равняется наибольшему из margin'ов
    ```
    
18. Что такое CSS препроцессор?
    
    ```jsx
    Это инструмент, который расширяет стандартные возможности CSS с помощью новых
    синтаксических конструкций, таких как миксины, циклы, переменные, вложенность и 
    другие.
    ```
    
19. Что такое z-index?
    
    ```jsx
    Управляет вертикальным порядком расположением элементом по оси Z. Применяется на
    элементы у которых position не static
    ```
    
20. Глобальные ключевые слова в CSS?
    
    ```jsx
    initial: Это ключевое слово устанавливает свойство в его начальное значение,
    как если бы оно не имело установленного значения.
    
    inherit: Это ключевое слово наследует значение свойства от своего родительского
    элемента. Если свойство у родительского элемента имеет установленное значение,
    то элемент будет наследовать это значение.
    
    unset: Это ключевое слово объединяет в себе initial и inherit. Если свойство
    установлено у элемента, оно будет взято из его значения. Если нет, то будет
    использовано значение, унаследованное от родительского элемента.
    ```
    
21. Для чего используется ключевое слово currentColor в CSS?
    
    ```jsx
    Ключевое слово currentColor в CSS используется для установки значения свойства,
    которое зависит от текущего цвета текста элемента.
    ```
    
22. Что такое псевдоклассы
    
    ```jsx
    это ключевые слова, которые добавляются к селекторам для выбора элементов,
    которые находятся в определенных состояниях или имеют определенные характеристики
    
    hover - при наведении
    first-child - первый элемент
    last-child - последний
    ```
    
23. Как отцентровать блок по горизонтали и вертикали
    
    ```jsx
    display: flex
    justify-content: center;
    align-items: center;
    ```
    
24. Что делает box-sizing: border-box;
    
    ```jsx
    Ширина и высота будут включать в себя padding и border
    ```
    
25. Что такое inline стили и какой они имеют приоритет
    
    ```jsx
    Они имеют второй приоритет и прописываются напрямую в html через style
    Первый приоритет имеет !important
    ```
    
26. Что такое БЭМ
    
    ```jsx
    Это методология блок элемент модификатор. Она подразумевает компонентный подход
    к веб разработке. В его основе лежит принцип разделения интерфейса на независимые
    блоки. Что позволяет легко и быстро разворачивать интерфейсы  и повторно
    использовать код
    ```
    
27. vh и vw при указании размером
    
    ```jsx
    vh - 1% от высоты браузера
    vw - 1% от ширины браузера
    ```
    
28. Какое свойство в flex отвечает за перенос при переполнении
    
    ```jsx
    flex-wrap: wrap
    ```
    
29. Как увеличить размер элемента при наведении не сдвигая соседние
    
    ```jsx
    transfrom
    ```
    

30. Единицы измерения(px и другие)

    ```jsx
    Абсолютные единицы (фиксированные)
    px — пиксели (базовая единица).
    cm, mm, in — сантиметры, миллиметры, дюймы (для печати).
    pt — пункты (1/72 дюйма, для печати).
    pc — пики (1/6 дюйма, для печати).

    Относительные единицы
    Относительно размера шрифта:
    em — относительно font-size родителя.
    rem — относительно font-size корневого элемента (html).
    ex — высота строчной буквы «x» (редко).
    ch — ширина символа «0» текущего шрифта.
    
    Относительно viewport (окна браузера):
    vw — 1% ширины окна.
    vh — 1% высоты окна.
    vmin — 1% от меньшей стороны окна.
    vmax — 1% от большей стороны окна.
    
    Относительно контейнера:
    cqw, cqh, cqi, cqb, cqmin, cqmax — относительно размеров контейнера (Container Queries).
    
    Проценты:
    % — относительно родительского элемента (размер зависит от свойства).
    
    Специальные:
    lh — высота строки текущего элемента.
    rlh — высота строки корневого элемента.
    ```

## JavaScript

1. Какие типы данных существуют в JS 
    
    ```jsx
    Есть примитивы и ссылочные типы данных.
    Примитивы: number, string, boolean, undefiend, null, Symbol, BigInt
    Ссылочные: Object
    https://learn.javascript.ru/types
    ```
    
2. В чём разница между операторами “==” и “===”
    
    ```jsx
    == - нестрогое равенство, сравнивает значение с приведением типов
    === - строгое равенство, сравнивает значение без приведения типов
    ```
    
3. Строгий режим (strict mode)?
    
    ```jsx
    Он позволяет использовать более строгий вариант JS синтаксиса.
    ```
    
4. Разница между function declaration и function expression?
    
    ```jsx
    Function declaration - обычная функция которая объявляется с помощью function
    Function Expression - созданная функция присваивается в переменную
    
    FD - создаётся интерпретитором до выполнения кода, следовательно можно вызвать до 
    объявления и это не вызовет ошибку.
    ```
    
5. Типы таймеров в JS
    
    ```jsx
    setTimeout - вызывается один раз после определённого времени
    setInterval - вызывается много раз с промежутком который мы указали
    ```
    
6. Что такое Hoisting (поднятие)?
    
    ```jsx
    Это механизм подъёма функций или переменной в глобальную или функциональную область
    видимости.
    
    console.log(a) // undefined
    var a = "hello world"
    console.log(a) // hello world
    ```
    
7. Что такое область видимости (Scope)?
    
    ```jsx
    Это место откуда мы имеем доступ к переменным или функциям. В JS есть три типа
    областей видимости.
    
    1) Глобальная - переменные и функции становятся глобальными и доступны из любого
    места в коде
    
    2) Функциональная - переменные и функции доступны только этой функции и вложенным
    функциям
    
    3) Блочная - переменные и функции доступны внутри фигурных скобках.
    ```
    
8. Разница между let, var, const
    
    ```jsx
    var, let, const
    1) var - функциональная область видимости (устаревшее)
    2) let - блочная область видимости
    3) const - блочная область видимости(нельзя переопределять), но если это объект
    или массив, то мы можем изменять
    ```
    
9. В чём разница между null и undefined
    
    ```jsx
    Оба означают пустое значение.
    null - присваиваем самостоятельно
    undefined - переменная которой не было присвоено значение. Функции которая
    ничего не возвращает и несуществующей свойства объекта.
    ```
    
10. Что обозначает this в JavaScript?
    
    ```jsx
    Это ссылка на объект, к свойствам которого можно получить доступ внутри
    вызова функции
    ```
    
11. Что такое функции высшего порядка (Higher Order Functions)?
    
    ```jsx
    Это функция которая возвращает другую функцию или же принимает другую функцию в
    качестве аргумента
    
    Пример таких функций: map, filter, reduce
    ```
    
12. Методы строк в JavaScript?
    
    ```jsx
    length - длина строки
    split
    toUpperCase
    toLowerCase
    indexOf
    replace
    trim
    ```
    
13. Методы массивов в JavaScript?
    
    ```jsx
    map
    filter
    reduce
    forEach
    reverse
    sort
    find
    findIndex
    push
    pop
    shift
    unshift
    join
    some
    every
    ```
    
14. Что такое чистая функция
    
    ```jsx
    Должно выполнятся два условия:
    
    1) В ней не должно быть побочных эффектов (видоизменение входных параметров, 
    http или dom запросы, изменение в файловой системе)
    
    2) Каждый раз она возвращает одинаковый результат, когда вызывается с тем же набором
    аргументов.
    ```
    
15. .map, .filter, .reduce, .forEach для чего нужны, особенности использования
    
    ```jsx
    .map - позволяет в массиве изменить каждое значение, при этом не изименяет исходный
    массив, а возвращает новое значение
    .filter - позволяет отфильтровать массив по определённому условию, так же не изменяет массив
    .reduce - позволяет пройтись по каждому элементу, выполнить действия и вернуть значение
    .forEach - просто пробег по массиву, ничего не возвращает и не меняет
    ```
    
16. Отличие стрелочных функций от функций объявленных через function
    
    ```jsx
    1) this - контекст, у стрелочных функций его нет, он заимствуется у родителя
    2) внутри стрелочных функций нельзя использовать arguments
    2) function declaration поднимается наверх своей области видимости
    ```
    
17. Что такое замыкание
    
    ```jsx
    Замыкание — это функция, у которой есть доступ к области видимости, сформированной
    внешней по отношению к ней функции даже после того, как эта внешняя функция
    завершила работу. Это значит, что в замыкании могут храниться переменные,
    объявленные во внешней функции и переданные ей аргументы.
    
    Когда доходит до вызова функции, создаётся контекст выполняния и лексическое
    окружение, по сути это объект который хранит список переменных и функции, и
    ссылку на родительское лексическое окружение
    
    https://habr.com/ru/companies/ruvds/articles/424967/
    ```
    
18. Что такое псевдомассив arguments?
    
    ```jsx
    Это коллекция аргументов, которая передаётся в функцию. 
    ```
    
19. Почему результат сравнения 2х объектов это false?
    
    ```jsx
    Потому что сравниваются по ссылке, а не по значению
    ```
    
20. Что такое прототипное наследование? Как создать объект без прототипа в JavaScript?
    
    ```jsx
    Прототипное наследование - это механизм наследования в языке программирования
    JavaScript, который основан на использовании прототипов объектов. В JavaScript
    каждый объект имеет свой прототип (или ссылку на другой объект), и он может
    наследовать свойства и методы от этого прототипа.
    
    Для создания объекта без прототипа в JavaScript вы можете использовать функцию
    Object.create(null).
    
    __proto__ можем задавать либо объект, либо null
    ```
    
21. Что такое шаблонные литералы и для чего они нужны

    ```jsx
    в косые кавычки можно вставить выражение ${} 
    ```
    
    
22. Что такое set и map и для чего они нужны?
    
    ```jsx
    Map - коллекция ключ/значение как и обычный объект,
    но основное отличие в том, что Map позволяет использовать ключи любого типа
    Set - это структура данных "множество" значений без ключей (своего
    рода массив), где каждое значение может появляться только один раз(уникальны)
    ```
    
23. как определить наличие свойств в объекте
    
    ```jsx
    Первый способ: вызов функции hasOwnProperty где параметром передаётся само свойство,
    и в случае если оно в объекте есть, возвращается true - при этом не заглядывает
    в прототипы
    Второй способ: воспользоваться оператором in ("key" in obj), который тоже вернёт
    true, при этом заглядывает в прототипы
    ```
    
24. Какие способы создание объекта существуют

    ```jsx
    a. С помощью функции
    
    b. C помощью литеральной нотации
    
    c. C помощью класса
    ```
    
    
25. Какие значения будут являться false значениями
    
    ```jsx
    null, undefined, NaN, 0, "", false, BigInt(0)
    ```
    
26. Разница между синхронными и асинхронными функциями
    
    ```jsx
    Синхронные функции являются блокирующими, в то время как асихнронные - нет.
    ```
    
27. Что такое AJAX?
    
    ```jsx
    это технология, которая позволяет обмениваться данными между веб-сервером и
    веб-страницей без необходимости перезагрузки всей страницы
    ```
    
28. Event Loop
    
    ```jsx
    https://www.youtube.com/watch?v=377qAu37OTE
    https://habr.com/ru/articles/681882/
    
    Event Loop - это механизм, который позволяет использовать неблокирующую модель
    ввода и вывода
    
    1) Есть стек вызовов, операции всегда попадают на вершину стека и с этой же вершины 
    они выполняются.
    2) Есть Web Api который предоставляет всякие таймауты, обработку слушателей событий,
    отправку fetch запросов3
    3) И есть очередь задач, Задачи из очереди попадают в стек только после вызова всех
    функций из стека(то есть когда стек очистится)
    4) Очередь задач делится на микротаски и макротаски
    5) Сначала выполняются все микротаски, потом происходит рендеринг, а потом одна
    макротаска (почему одна? потому что в макротаске может содержатся микротаска(например
    в setTimeout содержится Promise))
    
    Микрозадачи:
    Промисы (Promises)
    queueMicrotask() - позволяет создать микротаску явно
    MutationObserver - позволяет следить за изменениями в DOM
    
    Макрозадачи:
    setTimeout, setInterval
    Слушатели событий
    Асинхронные запросы XHR (XMLHttpRequest)
    requestAnimationFrame
    ```
    
29. Что такое Promise
    
    ```jsx
    Это специальный объект, предназначенный для работы с ассинхронным кодом и который
    содержит своё состояние. Вначале это pending, затем одно из двух fulfilled или
    rejected
    
    Для работы с результатом выполнения вычисления внутри промиса, используются методы:
    
    then - метод принимает два аргумента:
    	1)onFulfill - функция колбэк, которая будет вызвана, когда промис перейдёт в
    		состояние filfilled
    	2)onReject - функция колбэк, которая будет вызвана, когда промис перейдёт в
    		состояние rejected
    
    catch - метод принимает один аргумент:
    	1)onReject - функция колбэк, которая будет вызвана, когда промис перейдёт в
    		состояние rejected
    	*)Под капотом catch() содержит вызов then(), где первый колбэк установлен в 
    		undefined: catch(onReject) -> then(undefined, onReject)
    
    finally - метод принимает один аргумент:
    		1)onDone - функция колбэк, которая будет вызвана при завершении промиса
    		*)Под капотом finally() содержит вызов then(), где оба колбэка onDone:
    			finally(onDone) -> then(onDone, onDone)
    ```
    
30. **Разница между Promise.all(), Promise.allSettled(), Promise.any() и Promise.race()?**
    
    ```jsx
    Promise.all(): Принимает массив промисов и возвращает новый промис, который
    выполнится только тогда, когда все промисы в массиве будут выполнены успешно
    (resolved). Если хотя бы один промис из массива отклоняется (rejected), то
    возвращенный промис тоже будет отклонен. Результатом Promise.all() является
    массив результатов выполнения промисов в том же порядке, в котором они были
    переданы.
    Если в Promise.all() передать не промисы, он вернёт переданные не промисы в массив
    результатов как есть (под капотом при этом произойдёт его преобразование с помощью
    метода Promise.resolve()).
    
    Promise.allSettled(): Принимает массив промисов и возвращает новый промис, который
    будет выполнен, когда будут выполнены все переданные промисы. Результатом
    Promise.allSettled() является массив результатов выполнения промисов в том же порядке,
    в котором они были переданы.
    Если промис выполнился успешно, то на выходе получаем объект с двумя свойствами —
    status и value. status будет содержать строку 'fulfilled', а value — значение,
    которое передали при вызове resolve у промиса.
    Если промис выполнился с отказом, то на выходе получаем объект с двумя свойствами —
    status и reason. status будет содержать строку 'rejected', а reason — значение,
    которое передали при вызове reject у промиса
    
    Promise.any(): Принимает массив промисов и возвращает новый промис, который
    выполнится, когда хотя бы один промис из массива будет выполнен успешно (resolved).
    Если все промисы отклоняются (rejected), то возвращенный промис будет отклонен.
    Результатом Promise.any() является значение первого успешно выполненного промиса.
    
    Promise.race(): Принимает массив промисов и возвращает новый промис, который
    выполнится, когда первый промис из массива будет выполнен или отклонен.
    Результатом Promise.race() является значение или ошибка первого промиса, 
    который завершится.
    ```
    
31. Как использовать async/await для ассинхронных запросов
    
    ```jsx
    Это специальный синтаксис для работы с Promise.
    Функция обёрнутая в async всегда будет оборачивать результат который возвращается в 
    Promise.
    Обязательно нужно обернуть функцию в async и внутри неё пользоваться await
    ```
    
32. **Для чего используется цикл for…of?**
    
    ```jsx
    Цикл for...of в JavaScript используется для перебора элементов итерируемых
    объектов, таких как массивы, строки, коллекции Set и Map, и других объектов,
    которые поддерживают итерацию.
    ```
    
33. **В чём отличие оператора нулевого слияния (??) и оператора “ИЛИ” (||)?**
    
    ```jsx
    Оператор нулевого слияния (??) возвращает значение справа, только если значение
    слева равно null или undefined. В противном случае, оно возвращает значение слева.
    
    Оператор "ИЛИ" (||) возвращает первое истинное значение из операндов. Если
    все операнды являются ложными, то возвращает последний операнд.
    ```
    
34. Для чего нужен оператор Spread
    
    ```jsx
    Чтобы разворачивать массивы и объекты
    ```
    
35. Как избежать ссылочной зависимости при копировании объекта
    
    ```jsx
    1. Как раз использовать Spread оператор
    2. Либо использовать Object.assign({}, obj) и объект скропируется, но если внутри
    объекта есть ещё один объект, то он не скопируется, а сохранится ссылка
    3. Есть костыльный способ через JSON.parse(JSON.stringify(obj))
    4. использовать библиотеку для полного копирования, например Lodash 
    const obj2 = cloneDeep(obj)
    5. structuredClone(obj) - новый метод
    ```
    
36. Как поменять контекст функции
    
    ```jsx
    Использовать bind, apply, call
    
    bind - возвращает новуй функцию
    apply - передаём объект и аргументы в массиве
    call - передаём объект и аргументы через запяту.
    ```
    
37. Что такое тернарный оператор
    
    ```jsx
    Это как if else только записывается по другому
    const result = условие ? тогда : иначе
    ```
    
38. Что такое деструктуризация
    
    ```jsx
    Позволяет распаковать из массива или объекта кучи переменных
    const obj = {name: "Rufat", surname: "Safiullin"}
    const {name, surname} = obj
    ```
    
39. Какие способы с ассинхронным кодом вы знаете
    
    ```jsx
    1)async/await
    2)Промисы then/catch/finally
    3)callback (знаю, но не пользовался)
    ```
    
40. e.preventDefault() и e.stopPropagination() для чего нужны
    
    ```jsx
    preventDefault убирает события по умолчанию
    stopPropagination предотвращает всплытие, например есть див у которого onclick,
    и есть кнопка внутри и если кнопке сделать event.stopPropagination(), то слушатель
    div не вызовется
    ```
    
41. Как отслеживать и обрабатывать ошибки в JS
    
    ```jsx
    try catch finally
    ```
    
42. Что такое DOM Дерево
    
    ```jsx
    Это объектная модель документа. Которую браузер создаёт в памяти компьютера
    на основании Html кода полученного им от сервера. Имеет иерархическую структуру.
    ```
    
43. Типы узлов DOM-дерева?
    
    ```jsx
    Листовые — не содержат внутри себя других узлов
    Внутренние – у них есть узлы
    ```
    
44. Методы поиска элементов в DOM?
    
    ```jsx
    getElementById
    querySelectorAll
    querySelector
    ```
    
45. Виды событий в JavaScript?
    
    ```jsx
    События мыши: Включают события, связанные с перемещением мыши (например, mousemove),
    нажатием кнопок мыши (например, mousedown, mouseup, click) и скроллингом колесика
    мыши (например, wheel).
    
    События клавиатуры: Включают события, связанные с нажатием и отпусканием клавиш
    на клавиатуре (например, keydown, keyup) и вводом текста (например, input, change).
    
    События форм: Включают события, связанные с отправкой формы (например, submit),
    изменением значения элемента формы (например, input, change) и фокусировкой на
    элементах формы (например, focus, blur).
    ```
    
46. Как добавить и удалить обработчик события на DOM-элемент?
    
    ```jsx
    Через addEventListener("click", func)
    Через removeEventListener("click", func)
    ```
    
47. **Что такое распространение события (Event Propagation)?**
    
    ```jsx
    Распространение события (Event Propagation) - это механизм в JavaScript, который
    определяет порядок, в котором события передаются от родительских элементов к
    дочерним или от дочерних элементов к родительским в иерархии DOM.
    
    В DOM существуют два типа распространения события:
    
    Всплытие события (Event Bubbling): При всплытии события сначала обрабатывается
    самый вложенный элемент, на котором произошло событие, затем его родительские
    элементы по очереди до самого верхнего уровня документа (обычно document или window).
    То есть, событие "всплывает" от вложенных элементов к родительским.
    
    Погружение события (Event Capturing): При погружении события сначала обрабатывается
    самый верхний элемент в иерархии документа, а затем событие передается по очереди
    от родительских элементов до самого вложенного элемента. То есть, событие
    "погружается" от родительских элементов к вложенным.
    ```
    
48. Как получить свойство объекта
    
    ```jsx
    1)obj.name
    2)obj['surname']
    ```
    
49. **Разница между cookie, sessionStorage и localStorage**
    
    ```jsx
    cookie, sessionStorage и localStorage — это технологии для хранения данных на стороне
    клиента в браузере. Однако, у них есть различия в использовании и хранении данных.
    
    cookie — небольшой фрагмент данных, который отправляется сервером в браузер, а затем
    сохраняется в браузере клиента. Cookie могут храниться в течение определённого периода
    времени, определяемого сервером. Они используются для сохранения пользовательских
    настроек, данных авторизации и другой информации о пользователях.
    
    sessionStorage — объект, который позволяет сохранять данные в браузере на время сессии,
    т.е. пока вкладка браузера открыта. Данные сохраняются в виде пары ключ-значение, и
    они могут быть использованы для сохранения состояния приложения или другой информации,
    которая должна быть доступна только в течение сессии.
    
    localStorage — объект, который позволяет сохранять данные в браузере на неопределенный
    период времени, т.е. данные будут доступны даже после закрытия браузера и перезагрузки
    компьютера. Данные также сохраняются в виде пары ключ-значение и могут быть использованы
    для сохранения состояния приложения или другой информации, которая должна быть доступна
    в любое время.
    ```
    

50. Напишите простую функцию, чтобы проверить, является ли число целым

    ```jsx
    function isInteger(num) {
      return num % 1 === 0;
    }
    ```

51. **Написать код для получения текущего URL**

    ```jsx
    
    const currentUrl = window.location.href;
    ```

52. **Что такое Symbol и зачем нужен?**

    «Символ» представляет собой уникальный идентификатор. Символы гаранитровано уникальны, не конвертируются в строку.
    Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.
    Может пригодится если с объектом работает еще кто-то другой, например либа, чтобы не было путаницы имен/ключей.
    
    ```jsx
    
    let id = Symbol("id");
    
    let user = {
      name: "Вася",
      [id]: 123 // просто "id: 123" не сработает
    };
    
    // читаем символ из глобального реестра и записываем его в переменную
    let id = Symbol.for("id"); // если символа не существует, он будет создан
    ```

53. **разница между xmlhttprequest, fetch, axios**

    ```jsx
    xmlhttprequest старый, fetch современный, axios либа, еще лучше, т.к. встроенная поддержка интерсепторов, ловит исключения сам, встроенный abortController и т.д.
    <img width="905" height="644" alt="image" src="https://github.com/user-attachments/assets/9d6f7a2c-d58f-462d-b4a3-8654cbbea19b" />
    ```

54. **Critical Rendering Path**

    ```jsx
   1) Браузер отправляет запрос, сервак в ответе присылает html страницу в теле запроса
    2) Парсинг HTML
    3) DOM дерево html'а, парсится инкрементно (по очереди, есл есть ссылка на внешний ресурс, сначала получает и парсит его)
    4) CSSOM дерево стилей, создается синхронно, блокирует рендер. В отличии от HTML, CSS не может быть использован по частям в силу своей каскадной природы. Стили, описанные в документе ниже, могут переопределять и изменять стили, определённые ранее
    5) JS по дефолту блочит парсер, если не async или defer
    6) Render-дерево — это совокупность DOM и CSSOM. Это дерево, которое даёт представление о том, что в конечном итоге будет отображено на странице. Это означает, что оно захватывает только видимый контент и не включает, например, элементы, которые были скрыты с помощью CSS-правила display: none.
    7) Компоновка (layout) зависит от размеров экрана. Этот этап определяет, где и как на странице будут спозиционированы элементы и каковы связи между элементами. Размер вьюпорта определяется метатэгом, находящемся в <head> документа или, если тэг не представлен, будет использовано стандартное значение вьюпорта шириною в 980 пикселей.
    8) Отрисовка (paint) пикселей на экране. Когда дерево рендера (render tree) создано, компоновка (layout) произошла, пиксели могут быть отрисованы. При первичной загрузке документа (onload) весь экран будет отрисован. После этого будут перерисовываться только необходимые к обновлению части экрана. На этапе отрисовки браузер создает Paint Records, чтобы определить порядок рисования элементов, также определяется какие элементы рисовать первыми (z-index)
    9) Композиция - Когда разделы документа отрисованы на разных слоях, и один слой находится над другим или перекрывает его, становится необходима композиция. Этот шаг позволяет браузеру гарантировать, что каждый слой отрисован на экране в правильном порядке, а содержимое отображается корректно.
    ```

55. **for; for ... in ...; for... of…**

    ```
    1) For: полный контроль, работа с индексами, обратный проход
    2) for ... in ...: лучше только с объектами, идет по ключам, можно использовать с Object.keys/values/entries() (!!!медленно перебирает большие массивы)
    3) for ... of ...: с остальными структурами данных, массивами, сэтами, мапами, 
    ```

56. **jit-компилятор, как код обрабатывается бразуером**

    ```
    Браузер обрабатывает код, использующий JIT-компиляцию, путем его интерпретации, а затем трансляции наиболее часто выполняемых частей в машинный код непосредственно во время выполнения программы. Это позволяет значительно повысить скорость выполнения, поскольку после компиляции браузер напрямую запускает уже оптимизированный код, а не интерпретирует его снова.
    
    То есть, самые частовыполняемые участки кода комплируется в машинный код и уже вызывается в скомпилированным виде, что ускоряет работу.
    ```

57. **Что такое Интерсептор**

    ```
    Интерсептор — это паттерн перехвата и модификации запросов/ответов между клиентом и сервером. 
    В веб-разработке интерсепторы широко используются в HTTP-библиотеках (Axios, Fetch) и фреймворках (Angular, NestJS).
    ```
    
58. **Что такое Полифил**

    ```
    Полифил (Polyfill) — это код (обычно JavaScript), который добавляет современную функциональность в старые браузеры, которые её не поддерживают нативно.
    Что делает полифил:
    1)Проверяет, существует ли уже нужная функция в браузере
    2)Если нет — реализует её самостоятельно
    3)Позволяет использовать современный API во всех браузерах
    ```


## Паттерны JavaScript

1. На какие группы делятся паттерны
    
    ```jsx
    1)Структурные - определяют структуру представления классов/объектов
    2)Порождающие - паттерны отвечающие за создание объектов
    3)Поведенческие - паттерны для инкапсуляции (сокрытия) действий над объектами.
    ```
    
2. Singleton
    
    ```jsx
    Singleton - порождающий паттерн. Это паттерн гарантирует нам, что у класса будет
    один экземпляр и у него будет глобальный доступ
    
    let instance;
    let counter = 0;
    
    class Counter {
      constructor() {
        if (instance) {
          throw new Error("You can only create one instance!");
        }
        instance = this;
      }
    
      getInstance() {
        return this;
      }
    
      getCount() {
        return counter;
      }
    
      increment() {
        return ++counter;
      }
    
      decrement() {
        return --counter;
      }
    }
    
    const singletonCounter = Object.freeze(new Counter());
    export default singletonCounter;
    ```
    
3. Proxy
    
    ```jsx
    Proxy - структурный паттерн. Это паттерн по сути является прослойкой, который
    позволяет сделать что-то до или после обращения к оригинальному объекту.
    
    const person = {
      name: "John Doe",
      age: 42,
      nationality: "American"
    };
    
    const personProxy = new Proxy(person, {
      get: (obj, prop) => {
        console.log(`The value of ${prop} is ${Reflect.get(obj, prop)}`);
      },
      set: (obj, prop, value) => {
        console.log(`Changed ${prop} from ${obj[prop]} to ${value}`);
        return Reflect.set(obj, prop, value);
      }
    });
    ```
    

4.  Observer

    ```jsx
    Observer - поведенческий паттерн. Этот паттерн по сути создаёт механизм подписки,
    позволяющий одним объектам, следить за изменениями других объектов.
    ```

## TypeScript

1. **Что такое TypeScript?**
    
    ```jsx
    TypeScript - это язык программирования, который является надмножеством языка
    JavaScript.
    ```
    
2. **Основные компоненты TypeScript?**

    ```jsx
    Типы данных: TypeScript предоставляет различные встроенные типы данных,
    такие как number, string, boolean, object, array, tuple, enum, any, void,
    null, undefined, never и другие. Они позволяют указывать типы переменных,
    параметров функций и возвращаемых значений, обеспечивая статическую типизацию.
    
    Интерфейсы: Интерфейсы в TypeScript позволяют определять пользовательские типы,
    которые описывают форму объекта или класса. Они определяют набор свойств и их
    типы, которые должны быть реализованы объектом или классом.
    
    Классы: TypeScript поддерживает классы, которые позволяют объединять данные и
    методы в одном объекте. Классы могут иметь свойства, конструкторы, методы,
    наследование и другие концепции объектно-ориентированного программирования.
    
    Функции: TypeScript позволяет указывать типы параметров и возвращаемого значения
    функций. Он также поддерживает опциональные параметры, параметры по умолчанию,
    перегрузку функций и другие возможности для работы с функциями.
    ```

1. Особенности TypeScript
    
    ```jsx
    Статическая типизация
    ООП
    ```
    
2. Что такое декораторы?
    
    ```jsx
    Декораторы в TypeScript - это специальные функции, которые позволяют изменять
    поведение классов, методов, свойств и параметров
    ```
    
3. Поддерживает ли TypeScript перегрузку функций?
    
    ```jsx
    Да, TypeScript поддерживает перегрузку функций. Перегрузка функций позволяет
    определить несколько вариантов функции с различными сигнатурами (типами
    параметров и возвращаемого значения). Компилятор TypeScript будет выбирать
    подходящий вариант функции на основе переданных аргументов.
    ```
    
4. Что такое интерфейсы
    
    ```jsx
    Интерфейс используются для определения контракта, которые класс или объекты должны
    реализовывать
    ```
    
5. Чем отличаются Type Alias От Interface
    
    ```jsx
    1)В type alias можно положить не только объект, а любой тип, включая interface или
    другой type alias.
    2)Интерфейс может наследоваться от типов
    3)При объявлении интерфейсов с одинаковым именем интерфейс расширяется. Если же
    объявить два type alias с одинаковым именем, будет ошибка
    4)Интерфейсы могут наследоваться друг от друга. Это можно сделать при помощи
    ключевого слова extends. При наследовании интерфейс-потомок имеет все поля
    интерфейса-родителя и те поля, которые объявлены непосредственно у него самого.
    Type alias наследоваться не могут.
    5) Type alias можно расширить пересечением типов с помощью оператора &.
    6)Кортеж можно определить только с помощью типов
    
    type Person = {
      name: string;
      age: number;
    };
    
    type Employee = Person & {
      employeeId: number;
    };
    
    const employee: Employee = {
      name: "Bob",
      age: 30,
      employeeId: 67890
    };
    ```
    
6. Что такое enum и зачем он нужен?
    
    ```jsx
    
    Enum (перечисления) в TypeScript представляют собой способ организации набора 
    связанных значений под одним именем. Они могут быть особенно полезны, когда 
    необходимо определить коллекцию констант и обеспечить типобезопасность 
    при их использовании.
    
    Преимущества использования Enum:
    1) Читаемость и удобство: Enum делает код более читаемым и понятным, 
    предоставляя набор предопределенных значений, которые легко идентифицировать и 
    использовать.
    
    2) Типобезопасность: Enum обеспечивает типобезопасность, что помогает 
    предотвратить ошибки, например, когда неправильно используется значение, 
    не принадлежащее перечислению.
    
    3) Документирование: Использование Enum может служить формой 
    самодокументирования кода, делая его более понятным для других разработчиков.
    
    4) Простота рефакторинга: При использовании Enum легче вносить изменения в код,
    поскольку значения централизованно управляются в одном месте.
    
    5)Перевод enum в массив
    ```
    
7. Что такое Generic типы
    
    ```jsx
    дженерики — это возможность создавать интерфейсы, типы, классы и функции,
    работающие не только с одним, а с несколькими типами данных
    function identity<T>(arg: T): T {
      return arg;
    }
    ```
    
8. **Разница между типами void, never и unknown? typescript**
    
    ```tsx
    Тип void в TypeScript используется для указания, что функция не возвращает
    какое-либо значение. Он обычно используется как возвращаемый тип для функций,
    которые не возвращают результат, или для переменных, которые не имеют значения.
    
    Тип never в TypeScript представляет недостижимый код или функции, которые никогда
    не завершаются или не возвращают значение. Он используется, когда функция
    генерирует исключение или имеет бесконечный цикл. Также never может быть
    результатом для функций, которые всегда выбрасывают исключение или имеют
    условие недостижимости.
    
    Тип unknown в TypeScript представляет значение, о типе которого ничего не
    известно. Он является типом безопасной замены для any, так как в отличие от
    any, значение типа unknown требует проверки типов перед его использованием.
    ```
    
9. Utility Types
    
    ```jsx
    Readonly - все свойства только для чтения
    Required - все свойства обязательные
    Partial - все свойства необязательные
    Record - создаёт тип объекта, ключами которого являются первый параметр в дженерике
    					а значениями - второй параметр дженерика
    Pick - создаёт тип объекта, выбирает нужные свойства у интерфейса
    Omit - создаёт тип объекта, удаляет ненужные свойства у интерфейса
    Exclude - создаёт тип, исключая все типы которые передаются вторым аргументом
    ```
    
10. Что такое индексаторы
    
    ```jsx
    Индексатор говорит о том, что у объекта нет конкретных названий полей. Известен лишь
    тип полей и тип значения поля. Тип полей может быть или string, или number. Нельзя
    использовать литеральные типы или их объединения (по крайней мере в interface-ах и в
    таком виде)
    interface A {
        [index: number]: boolean;
    }
    ```
    
11. Что такое Type Guards и Type Assertions
    
    ```jsx
    Type Guards - это рантайм проверка, которая гарантирует, что значение всегда
    будет определённого типа. Нужен для сужения  типа, либо если данные приходят
    со стороннего сервера и нам надо убедиться в типе.
    
    const func = (value: unknown) => {
       if (typeof value === 'string') {
          value; // string
       } else {
          value; // unknown
       }
    }
    
    Что делать с функциями? Если функция возвращает boolean, то мы можем добавить
    Type Predicate и ts поймёт какой тип. Также можно сделать с кастомным интерфейсом
    
    function is<TypeName>(variable: unknown): variable is TypeName {
        // Return boolean value
    }
    
    Type Assertions - тоже самое, что и Type Guards, только там код выкидывает ошибку,
    либо возвращает тип
    
    function assertString(value: unknown): asserts value is string {
      if(typeof value !== 'string') {
        throw new Error('value must be string')
      }
    }
    ```
    
12. keyof typeof
    
    ```jsx
    https://stackoverflow.com/questions/55377365/what-does-keyof-typeof-mean-in-typescript
    ```

13. Generic Constraint

    ```jsx
    // С ограничением (T должен иметь свойство length)
    function identityWithConstraint<T extends { length: number }>(arg: T): T {
      console.log(arg.length); // ✅ Теперь можем обращаться к length
      return arg;
    }
    ```

## React

1. Что такое React?
    
    ```tsx
    React - это библиотека JavaScript для создания пользовательских интерфейсов.
    Она позволяет разработчикам создавать мощные и интерактивные веб-приложения,
    используя компонентный подход.
    
    Особенности реакта:
    1)Компонентный подход
    2)Виртуальный дом
    2)JSX
    ```
    
2. Для чего нужен атрибут key при рендере списков
    
    ```tsx
    Атрибут key используется для помощи React в эффективном обновлении элементов списка.
    Ключи должны быть уникальны.
    ```
    
3. Этапы и фазы жизненного цикла реакт компонентов
    
    ```tsx
    
    🏗 Монтирование
    Фаза рендеринга для монтирования заключается в том, что React формирует
    виртуальный DOM  и отображает его на странице. Например, отрендерился новый
    компонент и в Virtual DOM добавился объект, связанный с данным компонентом.
    
    Фаза согласования для монтирования всего приложения по сути отсутствует, т.к.
    до этого никакого Virtual DOM не существовало. Для монтирования отдельного
    реакт-элемента - он "с нуля" создается в DOM.
    
    Фаза фиксации заключается в том, что виртуальный DOM, сформированный на
    этапе рендеринга для монтирования, просто отображается в браузерном DOM.
    
    🔁 Обновление
    Фаза рендеринга для обновления заключается в том, что React пересчитывает
    виртуальный DOM и структуру, которую мы хотим отобразить в браузерном DOM.
    
    Фаза согласования заключается в том, что React сравнивает Virtual DOM с
    предыдущего этапа и только что рассчитанный.
    
    Фаза фиксации - применение точечных изменений в DOM дереве, например, для
    в случае со счетчиком изменяется строка с его значением.
    
    🗑 Демонтирование
    Демонтирование выделяют в отдельный этап, потому что часто при демонтировании
    компонентов нужно выполнить какую-то определенную логику. Обратите внимание,
    что фаза рендеринда при демонтировании отсутствует, потому что компонент
    просто пропадет и нет смысла высчитывать структуру, которая будет отображена далее.
    На этапе фиксации выполняется логика, которая должна быть выполнена
    при демонтировании компонента, например, могут быть вызваны какие-то
    функции, которые отписывают текущий компонент от событий и т.д.
    ```
    
4. react **Reconciliation**
    
    ```jsx
    У нас есть Сurrent tree, и есть Work-In-Progress tree, они сравниваются и только
    разница будет перерисована. После обновления DOM дерева нашего сайта,
    Work-In-Progress tree становится Сurrent tree.
    
    Плюсом React реализует эврестический алгоритм, который основывается на двух
    предположениях:
    1)Два элемента с разными типами произведут разные деревья
    2)Можем указать, какие элементы могут оставаться стабильными между ререндерами
    с помощью key
    ```
    
5. Что такое Fiber
    
    ```jsx
    Когда строится дерево React элементов, то для каждого элемента впервые,
    создаётся Fiber Node, как раз таки Fiber хранить пропсы, состояние,
    какие пропсы были, какие стали, что нужно сделать и тд.
    
    Fiber - это объект, у которого есть поля:
    stateNode (ссылка на ноду в доме);
    child, sibling;
    penfingProps, memoizedProps;
    memoizedState;
    
    Также есть эффекты, которую каждая Fiber нода выполняет. Эффекты это 
    по сути запросы данных, подписки, изменения в DOM
    
    Все эффекты связанны, то есть каждый эффект, знает о другом эффекте.
    По сути это список и у каждого списка есть nextEffect и мы может пойти
    к следующему эффекту и выполнять его. Все эффекты имеют приоритеты,
    и нам нужно их отсортировать, чтобы в начале выполнялись эффекты
    максимально важные для пользователя (анимации, изменить то что он видит,
    обработать ввод), уже потом данные какие-то отобразить и уже после,
    подготовить изменения которые он не видит на будущее.
    
    https://habr.com/ru/articles/786102/
    ```
    
6. Что такое React Hooks
    
    ```tsx
    React хуки (Hooks) - позволяют использовать состояние и другие React-функции в
    функциональных компонентах без необходимости создавать классовые компоненты.
    ```
    
7. useState
    
    ```jsx
    хранит стейт компонента, принимает initial value, это либо значение, либо функция
    которую реакт вызовет при mount компонента. Хук возвращает значение и функцию
    для изменения данного значения.
    
    Множественные вызовы функции изменения схлопываются в одно изменение (batching)
    нужен для того, чтобы ререндер вызывался не на каждый вызов функции, а всего лишь
    один раз
    
    Функция для изменения стейта может принимать колбэк, параметром для колбэка
    является текущее значение стейта.
    
    Для обновления массиво или объектов, нужно каждый раз создавать новое значение, а
    не изменять старое(иммутабельность)
    ```
    
8. useEffect
    
    ```jsx
    первым параметром хук принимает функцию, а вторым массив зависимостей, если
    зависимости изменяются, то effect отработает ещё раз. Также у useEffect есть
    функция возврата, которая отрабатывает при Unmount или update компонента (если есть
    зависимости)
    ```
    
9. useLayoutEffect
    
    ```jsx
    Один в один как useEffect, но срабатывает до отрисовки браузером
    ```
    
10. React.memo
    
    ```jsx
    Позволяет нам пропускать ререндеринг комонента когда его пропсы не изменяются
    ```
    
11. useCallback
    
    ```jsx
    Это хук, который позволяет нам кэшировать определение функции между ререндерами.
    
    Использовать стоит тогда, когда мы передаём функцию в мемоизированный компонент, 
    либо в зависимости useMemo, useEffect, etc.
    ```
    
12. useMemo
    
    ```jsx
    Это хук, который позволяет нам кжшировать результат вычисления между ререндерами.
    Нужно использовать, когда тяжёлые вычисления
    ```
    
13. useRef
    
    ```jsx
    Это хук. который помогает хранить ссылку на значение, которое не вызовет
    ререндер компонента.
    
    Самое частое применение для фокуса на инпуте.
    ```
    
14. useContext
    
    ```jsx
    Позволяет подписаться на контекст и получать данные в любом компоненте из этого
    контекста. Хук принимает контекст и возвращает значение контекста.
    ```
    
15. Правила (ограничения) использования хуков?
    
    ```tsx
    Хуки нельзя использовать внутри циклов и условий
    Хуки можно вызывать только из React-функций (из компонентов или других хуков)
    Хуки нужно именовать правильно: useMyHook
    Эти правило обусловлены двумя основными причинами:
    
    1. Сохранение порядка вызова хуков
    React полагается на порядок, в котором хуки вызываются,
    чтобы правильно ассоциировать состояние с соответствующим хуком.
    Каждый хук, вызываемый в компоненте, записывается в список; 
    этот список используется для сохранения состояния между рендерами. 
    Если хуки вызываются условно (например, внутри if или цикла for), 
    порядок их вызова может изменяться в зависимости от условий выполнения или
    итераций цикла. Это может привести к некорректному соответствию между хуками и
    их состоянием, вызывая ошибки в поведении компонента.
    
    2. Упрощение и предсказуемость кода
    ```
    
16. Что такое JSX
    
    ```tsx
    это расширение синтаксиса JavaScript, которое позволяет писать HTML-подобный
    код внутри JavaScript-кода. JSX используется в React для описания
    структуры пользовательского интерфейса.
    ```
    
17. **Что такое фрагмент (Fragment)? Почему фрагмент лучше, чем div?**
    
    ```tsx
    Фрагмент (Fragment) в React - это компонент, который используется для обертывания
    нескольких элементов без создания дополнительных уровней в DOM-структуре. Фрагмент
    позволяет группировать элементы вместе, не добавляя лишних элементов в DOM.
    
    Фрагменты полезны, когда вам нужно вернуть несколько элементов из компонента без
    необходимости оборачивать их в отдельный контейнер, такой как div. Использование
    фрагментов вместо div позволяет избежать создания лишних уровней в DOM-структуре,
    что может быть полезно для стилизации и улучшения производительности.
    ```
    
18. **Что такое синтетические события в React?**
    
    ```tsx
    Синтетические события (SyntheticEvent) в React - это обертка над нативными 
    браузерными событиями, которая предоставляет унифицированный интерфейс для работы
    с событиями в React-компонентах. Они предоставляют кросс-браузерную совместимость
    и абстракцию над различными типами событий
    ```
    
19. **Чем React-элемент отличается от React-компонента?**
    
    ```tsx
    React-элемент — это результат рендера React-компонента, т.е. результат вызова
    функции React.createElement().
    ```
    
20. что такое VDom
    
    ```jsx
    VDOM это копия DOM и нужно оно для того, чтобы сосредоточиться на логике взаимодействия
    с данными напрямую и не работать с DOM деревом. То есть мы можем вносить изменения в 
    копию, исходя из наших потребностей, а после этого применять эти изменения к реальному
    DOM. При этом происходит сравнение DOM дерева с его виртуальной копией. Определяется
    разница и запускается перерисовка только тех компонентов, которые были изменены.
    ```
    
21. Как отрисовать массив элементов в React
    
    ```jsx
    через .map() и обязательно нужно указывать key. Ключи помогают реакт идетифицировать
    какие элементы были изменены, добавлены или удалены.
    ```
    
22. Что будет если не указать key или он не будет уникальным?
    
    ```jsx
    1. Проблемы с производительностью
    React использует ключи для определения, когда элементы в списке изменяются, 
    добавляются или удаляются, чтобы минимизировать количество операций с DOM. 
    Если ключи отсутствуют или не уникальны, React не сможет точно идентифицировать 
    элементы, что может привести к неэффективным обновлениям и излишним перерисовкам, 
    замедляя ваше приложение.
    
    2. Некорректное поведение при обновлении состояния
    Ключи помогают React сохранять состояние между перерисовками для конкретных элементов. 
    Если ключи отсутствуют или не уникальны, состояние элементов может быть неправильно
    применено, что приведет к ошибочному или непредсказуемому поведению вашего приложения.
    Например, вводимые данные могут появиться в неправильных элементах списка.
    
    3. Проблемы с фокусом и выбором
    Аналогично проблемам с состоянием, отсутствие уникальных ключей может привести
    к неправильному управлению фокусом и выбором в вашем интерфейсе. Элементы могут
    терять фокус, или фокус может перемещаться непредсказуемо при обновлениях списка.
    
    4. Предупреждения и ошибки в консоли
    ```
    
23. Разница между контролируемыми элементами и неконтролируемыми элементами
    
    ```jsx
    Контролируемые где есть стейт и мы можем контролировать
    Неконтролируемы это где нету стейта а просто через ref
    ```
    
24. Что такое state manager
    
    ```jsx
    по сути глобальное хранилище которое можно использовать в любом компоненте
    ```
    

25. Что такое SOLID

    ```jsx
    S - принцип единственной ответственности (каждый класс должен делать ровно одну
    вещь)
    O - принцип открытости-закрытости (класс должен быть открыт для расширения, но закрыт
    для изменения)
    Например у нас есть компонент User, и нам сказали что нужно добавить роль админа или
    учителя. Тогда нужно создать какой-нибудь компонент UserProxy, который будет принимать
    роль, а также три компонента User, Admin, Teacher. И внутри UserProxy мы в зависимости
    от переданной роли, будем выбирать компонент, в объекте, где ключ это роль, а значение
    это компонент
    L - принцип подстановки Барбары Лисков
    I - принцип разделения интерфейса (компоненты не должны зависеть от свойств, которые
    они не используют)
    D - принцип инверсии зависимостей
    ```


26. Что такое HOC и зачем они нужны?
    
    ```jsx
    HOC - компоненты высшего порядка. Компонент высшего порядка - это компонент, который
    принимает компонент и возвращает новый компонент.
    Зачем нужны HOC:
    1) Повторное использование кода: HOC позволяют избежать дублирования логики
    в компонентах, предоставляя общую функциональность через обертку.
    2) Абстракция и изоляция: HOC могут абстрагировать сложную логику и помогать в
    управлении состояниями и взаимодействиями, не засоряя основной компонент.
    3) Инкапсуляция: HOC могут скрывать детали реализации, предоставляя 
    чистый интерфейс для взаимодействия.
    4) Манипулирование props: HOC могут добавлять, удалять или модифицировать props,
    передаваемые в оборачиваемые компоненты.
    Пример HOC:
    Допустим, у нас есть компоненты, которым нужно добавить логику загрузки данных. 
    Вместо того чтобы писать код загрузки в каждом компоненте, мы можем создать HOC,
    который добавит эту логику
    
    ```

27. **Новые хуки реакт 19**

    ```
    1) useActionState (ранее известный как useFormState)
    Упрощает управление состоянием форм и обработку результатов действий.
    2) useOptimistic
    Позволяет оптимистично обновлять UI до завершения асинхронной операции.
    3) use
    Экспериментальный хук для чтения ресурсов (промисы, контекст).
    4) useFormStatus
    Предоставляет статус родительской формы (только внутри <form>).
    5) useTransition улучшения
    Улучшенный хук для управления переходами между состояниями.
    6) useDeferredValue улучшения
    Лучшая интеграция с concurrent features.
    ```

28. **как реакт понимает, когда рендерить компонент, а когда маунтить заново**

    ```
    1) Поменялся тип элемента (допустим с <button> на <input>)
    2) Поменялся key
    3) изменился родитель или позиция в дереве
    ```


## Next JS

1. Чем CSR отличается от SSR
    
    ```jsx
    в CSR отрисовка всех страниц происходит в браузере
    в SSR отрисовка страниц происходит на веб сервере
    ```
    
2. Что такое Next js
    
    ```jsx
    Это фреймворк, который в основе использует React для построения SSR и SSG приложений
    ```
    
3. Как работают страницы и роутинг в Next js
    
    ```jsx
    Все страницы которые находятся в папке pages и установленное им имя будет именем
    роута, по которому они становятся доступными
    ```
    
4. Как реализовать навигацию по страницам
    
    ```jsx
    С помощью компонента Link 
    ```
    
5. Как сделать редирект
    
    ```jsx
    const router = useRouter()
    router.push('/')
    ```
    
6. Как работать с картинками
    
    ```jsx
    Импортируем компонент Image
    Нужно обязательно указать ширину и высоту
    также можно оптимизировать картинку, например пока картинка не видна, загрузить её
    блюр версию
    ```
    
7. Как добавить метаданные
    
    ```jsx
    Импортировать компонент Head
    и внутрь этого компонента можно добавить метаданные
    ```
    
8. Как получить данные с сервера
    
    ```jsx
    для осуществления ассинхронного запроса существуют функции
    1)getStaticProps
    2)getServerSideProps
    ```
    
9. Как реализовать динамический роутинг
    
    ```jsx
    Чтобы превратить обычный роут в динамический - имя страницы должно быть обёрнуто
    в квадратные скобки
    
    страница будет брать изменяющий id из пути и рендерится с необходимыми данными
    ```
    
10. Что такое api routes
    
    ```jsx
    Next js позволяет создавать свой собственный API
    ```
    

## Redux Toolkit And Redux

1. Redux 
    
    ```jsx
    Redux — это инструмент для управления состоянием данных и пользовательским интерфейсом 
    в приложениях JavaScript с большим количеством сущностей. 
    Представляет собой библиотеку JavaScript.
    ```
    
2. Redux Toolkit
    
    ```jsx
    Redux Toolkit — инструмент представляет собой набор практических решений и методов,
    предназначенных для упрощения разработки приложений с использованием Redux. 
    Разработчики данной библиотеки преследовали цель упростить типичные случаи 
    использования Redux.
    ```
    
3. Почему стоит выбирать Redux
    
    ```jsx
    Субъективные причины:
    1)Самый популярный стейт менеджер
    
    Объективные причины:
    1)Однонаправленный поток данных (из хранилища в компоненты, а не наоборот)
    2)Иммутабельность (состояние иммутабельно)
    3)Экосистема
    4)Моностор
    ```
    
4. Что такое Редьюсер в Redux?
    
    ```jsx
    Редьюсер (reducer) — это чистая функция, которая принимает предыдущее состояние и 
    экшен (state и action) и возвращает следующее состояние (новую версию предыдущего). 
    (previousState, action) => newState;
    ```
    

5. Что такое Actions

    ```jsx
    Actions - это информация, которая отправляет данные в стор исплользуя dispatch.
    Они обязательно содержат тип (type) и могут содержать дополнительные данные. 
    ```

1. Что такое Dispatch в Redux? 
    
    ```jsx
    dispatch — это функция Redux хранилища(store). 
    Вы вызываете store.dispatch , чтобы отправить действие. 
    Это единственный способ вызвать изменение состояния.
    Функция useDispatch выполняется синхронно!
    ```
    
2. Зачем нужна иммутабельность в Redux
    
    ```jsx
    1)Гарантия того, что данные не изменятся, следовательно у нас будет история
    изменений
    2)Возможны чистые функции, так как не меняем приходящие аргументы
    3)Redux использует для оптимизации (метод subscribe не может подписаться на какой-то
    кусочек состояния)
    ```
    
3. Что такое Immer и как он работает
    
    ```jsx
    Immer - позволяет нам писать мутабельный код, но оставить состояние иммутабельным
    
    Когда мы пытаемся сделать мутабельное обновление состояния, Immer с помощью Proxy
    перехватывает и не делаем его, но запоминает. У Immer есть функцию produce, которая
    первым аргументом получает стейт, а вторым функцию в котором мутабельное изменение
    
    const nextState = produce(state, draftState => {
    	draftState.counters.second.counter++
    })
    ```
    
4. Что такое селектор в redux и redux-toolkit?
    
    ```jsx
    селектор — это чистая функция, которая принимает глобальное состояние хранилища
    (store) в качестве аргумента и возвращает некоторую его часть. 
    
    Используя хук useSelector из библиотеки react-redux, он внутри себя сранвивает
    прошлое и текущее состояния. и определяет, делать перерендер или нет. Это возможно
    благодаря иммутабельности
    
    Правила использования селекторов:
    1)Нужно как можно меньше выбирать данные из селектора (например если доставать из
    селектора весь стейт, то тогда компонент будет перерисовываться на каждое
    изменение стейта)
    2)Желательно иметь сложность О(1), так как селекторы вызываются на каждый экшн (то
    есть очень часто)
    
    Также есть createAppSelector который позволяет кэшировать логику селекторов
    
    ```
    
5. Что такое slice?
    
    ```jsx
    В контексте Redux Toolkit, "slice" является концепцией, которая позволяет 
    упростить процесс организации логики управления состоянием в Redux. 
    Слайс представляет собой часть глобального состояния приложения и включает 
    в себя редьюсеры и действия для управления этой частью состояния.
    Функция createSlice() генерирует редьюсер и действия к нему.
    ```
    
6. Что такое Flux
    
    ```jsx
    Flux — это архитектурный подход, предложенный Facebook для создания клиентских 
    web-приложений. Он предполагает однонаправленный поток данных, что помогает 
    организовать сложные интерфейсы с динамичным контентом. 
    Redux является одной из реализаций идей Flux. 
    В контексте Redux, Flux архитектура характеризуется следующими основными принципами:
    
    1.Единое источник истины (Single Source of Truth): 
    Всё состояние приложения хранится в одном объекте-хранилище (store). 
    Это упрощает управление состоянием, его отладку и тестирование.
    
    2.Состояние только для чтения (State is read-only): 
    Единственный способ изменить состояние — это отправить действие (action), 
    объект описывающий, что должно произойти. Это гарантирует, что разные части
    приложения не могут изменять состояние напрямую и приводить систему в
    непредсказуемое состояние.
    
    3.Изменения производятся с помощью чистых функций:
     Для определения того, как действия трансформируют состояние хранилища, 
    используются редьюсеры (reducers). Редьюсер — это чистая функция, которая принимает 
    предыдущее состояние и действие, и возвращает новое состояние.
    
    Эти принципы помогают создавать масштабируемые и легко поддерживаемые приложения. 
    Redux вдохновлён Flux, но предлагает упрощенную реализацию с одним хранилищем и 
    редьюсерами, что делает его более предсказуемым и легким в изучении.
    ```
    

## Архитектура
1. GRASP

    ```jsx
   (General Responsibility Assignment Software Patterns) — шаблоны проектирования, используемые для решения общих задач по назначению обязанностей классам и объектам.
   low coupling - низкая связность (модули слабо связаны между собой, чаще всего 1-й связью)
   high cohesion - высокая дружность (сущности/компоненты связаны между собой в модуле)
   ```
    
3. Принципы Clean Architecture

    ```jsx
   Dependency Inversion - Инверсия зависимостей, разворот зависимостей, поток управления не совпадает с направлением зависимостей (например слоты)
   Фасад - Защита внутренней реализации (Публичное АПИ, инкапсуляция)
   Одностороние и/или двухсторонние архитектурные границы - Одностороняя зависимость (слои FSD)
   Принцип ацикличных зависимостей
   Принцип устойчивых зависимостей - Зависимости направленны в сторону устойчивости (способность сохранять свое состояние при внешних воздействиях)
   Принцип устойчивых абстракций (нет в FSD) - чем абстрактнее, тем устойчивее
   Кричащая архитектура - По архитектуре ясно, что где находится и что делает приложение
    ```
   
3. DDD (Domain Driven Design)

    ```jsx
   Домен - Часть бизнес логики, по сути модуль, ответственный за свой процесс
   Ubiquitous language (Единный язык) - Бэк и фронт используют одни именна для избегания недопониманий
   Bounded Context - Одна сущность может по разному  называться в разных доменах (user/client/student)
    ```
        

## Общие

1. HTTP
    
    ```jsx
    протокол предназначенный для передачи данных по сети.
    ```
    
2. Из чего состоит HTTP Запрос
    
    ```jsx
    1)строка запроса(метод, урл адрес)
    2)заголовки(описывают тело сообщений, пережают различные параметры)
    3)тело запроса(данные)
    ```
    
3. что такое restapi
    
    ```jsx
    Архитектурный подход к построению api.
    Основная идея лежит в разделение разных операций. Чаще всего это операции crud при
    обращении к одному и тому же url с помощью http методов
    ```
    
4. Что такое CORS? Зачем он был придуман? Он обезопашивает пользователя или сервер? 
   ```jsx
   CORS (Cross-Origin Resource Sharing) — это механизм безопасности в браузерах, который ограничивает межсайтовые (отличные домен, протокол или порт) HTTP-запросы по умолчанию, но позволяет серверу явно указать, какие внешние источники (домены) могут получать доступ к его ресурсам.
    Он нужен для защиты клиента от злоумышлеников, которые могут отправить данные из его сессии.
    Также если используются непростые методы (GET, POST, HEAD) или заголовки (Accept, Accept-Language, Content-Language, Content-Type*),
    то отправляется дополнительный preflight запрос
    Допустимый Content-Type: application/x-www-form-urlencoded, text/plain, multipart/form-data   
    Preflight — это дополнительный OPTIONS-запрос, который браузер автоматически отправляет перед основным запросом для проверки безопасности,
    сервер дает ответ, есть ли доступ у клиента и только потом отправляет оригинальный запрос
    Заголовки запроса:
    Origin — автоматически добавляется браузером при кросс-доменном запросе
    Заголовки ответа сервера:
    Access-Control-Allow-Origin — какие домены разрешены (* или конкретный домен)
    Access-Control-Allow-Methods — разрешенные HTTP-методы
    Access-Control-Allow-Headers — разрешенные заголовки запроса
    Access-Control-Allow-Credentials — разрешены ли куки/авторизация
    Access-Control-Expose-Headers — какие заголовки ответа будут доступны JavaScript
    Access-Control-Max-Age — кеширование preflight-ответов
   ```

5. Что такое CSRF-атака? Как она работает? Опиши, как реализуется механизм защиты от CSRF-атак.
    ```jsx
    CSRF (Cross-Site Request Forgery) — это тип атаки на веб-приложения, при котором злоумышленник заставляет авторизованного пользователя выполнить нежелательные действия
    в приложении от лица пользователя, где он аутентифицирован. Выполняется обычно через теги на   странице, форма или картинка, которая не видна пользователю, но отправляет запрос, обходит CORS.
    Способы защиты:
    1. CSRF-токен - сервер генерирует уникальный токен для каждой сессии, токен включается во все формы и запросы изменяющие состоянию, сервер проверяет токен на соответствие
    2. SameSite-атрибут для кук: проверяет что куки приходят с того же ресурса
    3. Проверка заголовков Origin/Referer
    ```

6. Как работает JWT авторизация? Из каких токенов она обычно состоит? Где обычно хранят эти токены? Из каких частей состоит основной токен? Зачем внутрь JWT токена иногда складывают данные пользователя?
   ```jsx
    JWT (JSON Web Token) — это стандарт для создания токенов доступа, основанный на JSON.
    Авторизация работает так:
    1. Пользователь вводит креды
    2. Сервер их проверяет и создает JWT-токен
    3. Токен отдается клиенту
    4. Клиент использует токен на все следующие запросы
    5. Сервер их проверяет
    JWT авторизация обычно используют два токена - access и refresh
    Access - кратковременный, 10-15 минут, используется для запросов, обычно хранится в памяти/куках
    Refresh - долгосрочный, 7-30 дней, хранится в http-only cookie (нельзя прочитать с клиента), используется для получения нового access
    Когда просрачивается access, клиент по рефреш токену запрашивает новый access
    Токен состоит из 3-х частей разделенных точкой: закодированные заголовки, закодированные креды пользака, и подпись по секретному ключу.
    Внутрь JWT токена складывают данные пользователя чтобы уменьшить нагрузку на БД, т.к. можно сразу обращаться к данным в токене, не нужно хранить сессии на сервере, и чтобы токен был уникальным для каждого юзера
   ```

7. Что такое OAuth? Подробно распиши процесс oauth-авторизации. Можно ли совмещать его с JWT авторизацией?
    ```jsx
    OAuth 2.0 — это протокол делегированного доступа. Его основная цель — позволить приложению (клиенту) получать ограниченный доступ к защищенным ресурсам пользователя на другом сервисе (провайдере), без передачи пароля.
    1. Пользователь нажимает "Войти через Google", отправляется запрос от приложения к гуглу
    2. Пользователь переходит в среду гугла и предоставляет данные, кнопка "Разрешить"
    3. Гугл редериктет обратно на страницу приложения с одноразовым кодом доступа
    4. Приложения забирает код и отправляет со своего бекенда на бекенд гугла, чтобы получить токен (защита от csrf)
    5. Гугл проверяет и возвращает обратно
    
    Совмещение OAuth и JWT распрастранненая и хорошая практика. 
    1. OAuth используется как "шлюз" для входа и выдачи разрешений
    2. Ваш backend создает свой собственный JWT, валидируя access_token гугла
    3. Клиент работает с вашим API, используя ваш JWT
    ```

1. HTTP 1 / 1.1 / 2 / 3 (в чём разница между версиями)

2. WebSocket

1. События жизненного цикла страницы

1. Критические этапы рендеринга

1. Forced Reflow(вытекает из предыдущего вопроса и вызывает перерисовку всей страницы в  результате каких-то действий пользователя)

1. Отличие http От https → TLS → асинхронное шифрование (справа налево изучать)

1. CSP

1. Пользовательские данные и Cookie (HTTP-only и Secure)
